package local.poc.blockchain.customers.management.registration.service.impl;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Service;

import local.poc.blockchain.customers.management.registration.persistence.model.ContactMessengerProvider;
import local.poc.blockchain.customers.management.registration.persistence.model.ContactTelephoneType;
import local.poc.blockchain.customers.management.registration.persistence.model.CorporationOfficialDocumentType;
import local.poc.blockchain.customers.management.registration.persistence.model.CorporationType;
import local.poc.blockchain.customers.management.registration.persistence.model.Country;
import local.poc.blockchain.customers.management.registration.persistence.model.DBReg;
import local.poc.blockchain.customers.management.registration.persistence.model.PersonOfficialDocumentType;
import local.poc.blockchain.customers.management.registration.persistence.model.PersonSex;
import local.poc.blockchain.customers.management.registration.persistence.model.Reference;
import local.poc.blockchain.customers.management.registration.persistence.repository.ContactMessengerProviderRepository;
import local.poc.blockchain.customers.management.registration.persistence.repository.ContactTelephoneTypeRepository;
import local.poc.blockchain.customers.management.registration.persistence.repository.CorporationOfficialDocumentTypeRepository;
import local.poc.blockchain.customers.management.registration.persistence.repository.CorporationTypeRepository;
import local.poc.blockchain.customers.management.registration.persistence.repository.CountryRepository;
import local.poc.blockchain.customers.management.registration.persistence.repository.PersonOfficialDocumentTypeRepository;
import local.poc.blockchain.customers.management.registration.persistence.repository.PersonSexRepository;
import local.poc.blockchain.customers.management.registration.persistence.repository.RefRepo;
import local.poc.blockchain.customers.management.registration.service.RefCheckerService;
import local.poc.blockchain.customers.management.registration.service.exception.RefCheckerServiceException;

@Service
public class RefCheckerServiceImpl implements RefCheckerService {
	
	@Autowired
	private ContactMessengerProviderRepository contactMessengerProviderRepository;
	
	@Autowired
	private ContactTelephoneTypeRepository contactTelephoneTypeRepository;
	
	@Autowired
	private CorporationOfficialDocumentTypeRepository corporationOfficialDocumentTypeRepository;
	
	@Autowired
	private CorporationTypeRepository corporationTypeRepository;
	
	@Autowired
	private CountryRepository countryRepository;
	
	@Autowired
	private PersonOfficialDocumentTypeRepository personOfficialDocumentTypeRepository;
	
	@Autowired
	private PersonSexRepository personSexRepository;
	
	private
	<R extends CrudRepository<? extends Reference, Long> & RefRepo>
	Set<Long>
	getPendingValues(R repository) {
		Set<Long> pendingRefValues = new HashSet<>(repository.refValues());
		Set<Long> repositoryRefValues = new HashSet<>();
		repository.findAll().forEach(x -> repositoryRefValues.add(x.getId()));
		pendingRefValues.removeAll(repositoryRefValues);
		return pendingRefValues;
	}
	
	@Override
	public void checkForContactMessengerProviderRepository(boolean insertIfNotFound)
	throws RefCheckerServiceException {
		Set<Long> pendingValues = getPendingValues(contactMessengerProviderRepository);
		if(!pendingValues.isEmpty()) {
			if(!insertIfNotFound) {
				throw new RefCheckerServiceException(
					"ContactMessengerProvider has not the values: " +
					Arrays.toString(pendingValues.toArray()));
			}
			List<ContactMessengerProvider> providerList = new ArrayList<>();
			for(Long pendingValue : pendingValues) {
				ContactMessengerProvider.Ref ref =
					ContactMessengerProvider.Ref.fromValue(pendingValue);
				DBReg reg = new DBReg();
				reg.setCreatedDate(new Date());
				reg.setCreator(this.getClass().getCanonicalName());
				ContactMessengerProvider provider = new ContactMessengerProvider();
				provider.setId(ref.getValue());
				provider.setName(ref.name());
				provider.setDescription("Autogenerated | " + ref.name());
				provider.setDbReg(reg);
				providerList.add(provider);
			}
			contactMessengerProviderRepository.saveAll(providerList);
		}
	}
	
	@Override
	public void checkForContactTelephoneTypeRepository(boolean insertIfNotFound)
	throws RefCheckerServiceException {
		Set<Long> pendingValues = getPendingValues(contactTelephoneTypeRepository);
		if(!pendingValues.isEmpty()) {
			if(!insertIfNotFound) {
				throw new RefCheckerServiceException(
					"ContactTelephoneType has not the values: " +
					Arrays.toString(pendingValues.toArray()));
			}
			List<ContactTelephoneType> telephoneTypeList = new ArrayList<>();
			for(Long pendingValue : pendingValues) {
				ContactTelephoneType.Ref ref =
						ContactTelephoneType.Ref.fromValue(pendingValue);
				DBReg reg = new DBReg();
				reg.setCreatedDate(new Date());
				reg.setCreator(this.getClass().getCanonicalName());
				ContactTelephoneType telephoneType = new ContactTelephoneType();
				telephoneType.setId(ref.getValue());
				telephoneType.setName(ref.name());
				telephoneType.setDescription("Autogenerated | " + ref.name());
				telephoneType.setDbReg(reg);
				telephoneTypeList.add(telephoneType);
			}
			contactTelephoneTypeRepository.saveAll(telephoneTypeList);
		}
	}
	
	@Override
	public void checkForCorporationOfficialDocumentTypeRepository(boolean insertIfNotFound)
	throws RefCheckerServiceException {
		Set<Long> pendingValues = getPendingValues(corporationOfficialDocumentTypeRepository);
		if(!pendingValues.isEmpty()) {
			if(!insertIfNotFound) {
				throw new RefCheckerServiceException(
					"CorporationOfficialDocumentType has not the values: " +
					Arrays.toString(pendingValues.toArray()));
			}
			List<CorporationOfficialDocumentType> documentTypeList = new ArrayList<>();
			for(Long pendingValue : pendingValues) {
				CorporationOfficialDocumentType.Ref ref =
						CorporationOfficialDocumentType.Ref.fromValue(pendingValue);
				DBReg reg = new DBReg();
				reg.setCreatedDate(new Date());
				reg.setCreator(this.getClass().getCanonicalName());
				CorporationOfficialDocumentType documentType = new CorporationOfficialDocumentType();
				documentType.setId(ref.getValue());
				documentType.setName(ref.name());
				documentType.setDescription("Autogenerated | " + ref.name());
				documentType.setDbReg(reg);
				documentTypeList.add(documentType);
			}
			corporationOfficialDocumentTypeRepository.saveAll(documentTypeList);
		}
	}
	
	@Override
	public void checkForCorporationTypeRepository(boolean insertIfNotFound)
	throws RefCheckerServiceException {
		Set<Long> pendingValues = getPendingValues(corporationTypeRepository);
		if(!pendingValues.isEmpty()) {
			if(!insertIfNotFound) {
				throw new RefCheckerServiceException(
					"CorporationType has not the values: " +
					Arrays.toString(pendingValues.toArray()));
			}
			List<CorporationType> corporationTypeList = new ArrayList<>();
			for(Long pendingValue : pendingValues) {
				CorporationType.Ref ref =
						CorporationType.Ref.fromValue(pendingValue);
				DBReg reg = new DBReg();
				reg.setCreatedDate(new Date());
				reg.setCreator(this.getClass().getCanonicalName());
				CorporationType corporationType = new CorporationType();
				corporationType.setId(ref.getValue());
				corporationType.setName(ref.name());
				corporationType.setDescription("Autogenerated | " + ref.name());
				corporationType.setDbReg(reg);
				corporationTypeList.add(corporationType);
			}
			corporationTypeRepository.saveAll(corporationTypeList);
		}
	}
	
	@Override
	public void checkForCountryRepository(boolean insertIfNotFound)
	throws RefCheckerServiceException {
		Set<Long> pendingValues = getPendingValues(countryRepository);
		if(!pendingValues.isEmpty()) {
			if(!insertIfNotFound) {
				throw new RefCheckerServiceException(
					"CountryRepository has not the values: " +
					Arrays.toString(pendingValues.toArray()));
			}
			List<Country> countryList = new ArrayList<>();
			for(Long pendingValue : pendingValues) {
				Country.Ref ref =
						Country.Ref.fromValue(pendingValue);
				DBReg reg = new DBReg();
				reg.setCreatedDate(new Date());
				reg.setCreator(this.getClass().getCanonicalName());
				Country country = new Country();
				country.setId(ref.getValue());
				country.setName(ref.getName());
				country.setAlpha2(ref.getAlpha2());
				country.setAlpha3(ref.getAlpha3());
				country.setDescription("Autogenerated | " + ref.name());
				country.setDbReg(reg);
				countryList.add(country);
			}
			countryRepository.saveAll(countryList);
		}
	}
	
	@Override
	public void checkForPersonOfficialDocumentTypeRepository(boolean insertIfNotFound)
	throws RefCheckerServiceException {
		Set<Long> pendingValues = getPendingValues(personOfficialDocumentTypeRepository);
		if(!pendingValues.isEmpty()) {
			if(!insertIfNotFound) {
				throw new RefCheckerServiceException(
					"PersonOfficialDocumentType has not the values: " +
					Arrays.toString(pendingValues.toArray()));
			}
			List<PersonOfficialDocumentType> documentTypeList = new ArrayList<>();
			for(Long pendingValue : pendingValues) {
				PersonOfficialDocumentType.Ref ref =
						PersonOfficialDocumentType.Ref.fromValue(pendingValue);
				DBReg reg = new DBReg();
				reg.setCreatedDate(new Date());
				reg.setCreator(this.getClass().getCanonicalName());
				PersonOfficialDocumentType documentType = new PersonOfficialDocumentType();
				documentType.setId(ref.getValue());
				documentType.setName(ref.name());
				documentType.setDescription("Autogenerated | " + ref.name());
				documentType.setDbReg(reg);
				documentTypeList.add(documentType);
			}
			personOfficialDocumentTypeRepository.saveAll(documentTypeList);
		}
	}
	
	@Override
	public void checkForPersonSexRepository(boolean insertIfNotFound) throws RefCheckerServiceException {
		Set<Long> pendingValues = getPendingValues(personSexRepository);
		if(!pendingValues.isEmpty()) {
			if(!insertIfNotFound) {
				throw new RefCheckerServiceException(
					"PersonSex has not the values: " +
					Arrays.toString(pendingValues.toArray()));
			}
			List<PersonSex> personSexList = new ArrayList<>();
			for(Long pendingValue : pendingValues) {
				PersonSex.Ref ref =
						PersonSex.Ref.fromValue(pendingValue);
				DBReg reg = new DBReg();
				reg.setCreatedDate(new Date());
				reg.setCreator(this.getClass().getCanonicalName());
				PersonSex personSex = new PersonSex();
				personSex.setId(ref.getValue());
				personSex.setName(ref.name());
				personSex.setDescription("Autogenerated | " + ref.name());
				personSex.setDbReg(reg);
				personSexList.add(personSex);
			}
			personSexRepository.saveAll(personSexList);
		}
	}
	
	@Override
	public void checkAll() throws RefCheckerServiceException {
		checkForContactMessengerProviderRepository(true);
		checkForContactTelephoneTypeRepository(true);
		checkForCorporationOfficialDocumentTypeRepository(true);
		checkForCorporationTypeRepository(true);
		checkForCountryRepository(true);
		checkForPersonOfficialDocumentTypeRepository(true);
		checkForPersonSexRepository(true);
	}
	
}
