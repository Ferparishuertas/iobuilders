###Disclaimer
**This document is a proposal written by Gonzalo Carbajosa as a potential solution for IoBuilder's POC (Proof Of Concept) on a tokenized money system.**

The following areas will be tackled in this document by providing potential solutions to them:
1. Tech + Architecture
2. Team
3. Culture

# Tech + Architecture
The first milestone to reach is to achieve a working MVP (Minimum Viable Product) with basic fiat-to-token on and off ramps functionality. This MVP will be composed of the following components, listed from most to least important:

### Service layer:
Its the most important component of the architecture, since it will handle the business logic and will be the link between user actions and blockchain settlement operations.  
A public **REST API** will be in charge of handling user requests generated by the wallets via **HTTP** requests. This API would ideally be written in a JSON-friendly language such as Javascript, using a lightweight and battle tested stack like **Express** running on top of a **Node.js** server and persist data to a JSON native database such as **MongoDB**, **CouchDB** or **Elasticsearch**.

These events would be processed by a backend artefact. For this system, the language of choice would be **Java** or **Scala**, due to their robustness, massive open source communities and, in the case of Java, being less error-prone and testable due to its strong-typed nature.

In order to integrate the Node.js and Java/Scala artefacts, two mechanisms are proposed:

- A queuing system using **RabbitMQ** or **Kafka** message queues.  
For this approach, the backend system would have to be built around an integration framework such as **Spring Integration** or **Apache Camel**, running on top of a **Spring Boot** application.  
Events would be generated by the Node.js artefact and received by the backend via message queues making use of their **Pub/Sub** (publish-subscribe) capabilities.  
    - Pros:
        - Higher throughput
        - Scalability
        - Easier to store events
	- Cons:
	    - Higher complexity
	    - Potential loss of messages

- A Node.js-to-Java/Scala bridge library such as <https://www.npmjs.com/package/node-java-bridge/> that would invoke Java methods directly on the .jar files.
	- Pros:
		- Shorter initial development times
		- Architectural simplicity
	- Cons:
		- Potential performance penalty as the architecture scales
		- Having to rely on third-party libraries and small projects that might be abandoned in the future

In order for the backend artefact to interact with the Ethereum network and the smart contracts, the **web3j** library would be used.   
The backend project would be managed with a tool such as **Maven** or **Gradle**.

### Blockchain settlement layer:
The backend artefact would have to ultimately settle its transactions on a blockchain. Initially, **Ethereum** or J.P Morgan's **Quorum** would be the supported projects. In order to support all token and user identity functionality, two smart contracts would need to be written.

- An **ERC20**-compliant contract or tokenizer/detokenizer that would generate an initial amount of tokens and act as an accountability and balance system for the token holders.

- An **ERC725**-compliant contract that would provide entity (human or otherwise) identity verification.

These contracts would be written in **Solidity** and the **Truffle** suite would be used for development and deployment purposes.  
In addition to this, an Ethereum full node would have to be deployed in order to be able to unilaterally validate our own transactions.

### Mobile wallets (iOS and Android):
Mobile apps are very important for this project, since they are the only way for users to interact with the platform, and therefore they need to be intuitive, fast and reliable.  
Since time constraints are big, the best approach would be to take inspiration from an already-working project such as decentralized exchange **Abra** (<https://www.abra.com/>), **Coinbase** (<https://www.coinbase.com/>) or **MCO** (<https://mco.crypto.com/en/>) apps.

In order to avoid having to spend twice the time coding native iOS and Android apps, a code generating framework such as **React Native**, **Flutter** or **Apache Cordova** would be used.

The wallet software would also be in charge of gathering and performing initial validations on user documents for **KYC** (Know Your Customer) and **AML** (Anti Money Laundering) purposes.  
These documents would include a selfie and passport/id card images and a proof of residence (bank statement, household bill, etc) document, and would ideally be validated automatically or by using a third-party service such as **Jumio** (<https://www.jumio.com/>).

### Third-party APIs
In order to interact with third-party entities such as Iberpay, Momopocket, Inversis etc. a set of well-defined **REST APIs** would need to be published. They would ideally be developed using the same tech stack as the wallet APIs (Node.js + Express).

All of these components would be hosted on a **PAAS** (Platform-As-A-Service) cloud hosting provider such as **AWS** (Amazon Web Services) or **Microsoft Azure** due to its lower setup, maintenance and scaling costs and higher reliability compared to traditional servers.

Ideally all components would be containerized using a tool like **Docker** or **Kubernetes**. This approach would reduce deployment times and give much needed flexibility when it came time to scale the infrastructure, since it allows to scale artefacts up or down in a matter of minutes.

The deployment pipeline would be composed by a **CI** (Continuous Integration) tool such as **CircleCI** or **Travis** that would integrate with a **Git** source code hosting service such as **Bitbucket** or **GitHub**.  
The CI tool would build the projects, create a container image and deploy this image to an **Amazon ECS** (Elastic Container Service) or equivalent that would finally run the software.

# Team
A good development team is very important to the success of any tech company, but it's absolutely key when it comes to POC projects and market-prospecting ventures.  
Due to the tight time constraints (4 months), the team needs to be a small and multidisciplinary one, composed by the following members (in no particular order):

   - **1 CTO**/**product owner** that would be in charge of day-to-day duties such as sprint planning.
   - **2 Full Stack** developers that would develop the APIs and backend components.
   - **1 Frontend**/**mobile developer** whose duty would be to develop the mobile apps and ideally help the Full Stack developers with the APIs.
   - **1 Backend**/**blockchain developer** capable of writing the smart contracts and dealing with all of the aspects of blockchain development. This person should ideally be able to help the Full Stack developers with the backend project too.
   - **1 DevOps** engineer that would be in charge of the CI pipeline and cloud infrastructure and **QA** (Quality Assurance) duties such as test automation.
    
# Culture
Given that the team will go through rough and stressful times during the project, is very important for everyone to keep in mind the priorities and the reasons that brought everyone on board. This can be more easily achieved if good development practices are enforced and a healthy and positive atmosphere is created since the beginning.

When it comes to **coding** good practices, the following measures should be enforced:
- Apply **SOLID** principles to the code. This will help keep the codebase clean, concise, easy to maintain and review, less error-prone etc.
- Documentation is good, but it's even better to have readable and concise code. Code comments have to be maintained and updated as the codebase evolves, or otherwise they become imprecise and misleading, therefore comments should only added where really needed.  
  For APIs, a documentation tool such as **Swagger** should be used in order to document what each endpoint does, the parameters it accepts, the information it returns, etc.
- Work on a pull request-centric process. By creating short and concise pull requests, divided in smaller and isolated commits, it's much easier for everyone to keep track of what they, and the rest of the members of the team are doing. This is also important for issue-tracking and sprint-handling reasons.  
  In teams with more than one member, it's mandatory for at least another member of the team to review and validate each pull request.  
  It might seem like more time-consuming initially, but reality is that by validating someone else's code, bugs are spotted, code quality is improved and most importantly, everyone is more aware of the codebase,
  so that when they have to work on code they haven't written, they have a good knowledge of it.
- Use **TDD** (Test-Driven Development) when possible, and always keep in mind tests are part of the feature and never add any functionality that hasn't got unit and/or integration tests. A nice addition would be to add Sonarqube to the CI pipeline in order to have some metrics on code quality.
- Use **BDD** (Behavior-Driven Development). This is a very important piece of the QA process, since it allows for the entire flow of the application to be tested like real-world users will, and it creates unique scenarios that unit or integration tests are not able to replicate.  
  Libraries like **Cucumber** for the APIs and backend and **Appium** for the wallet apps (and the entire application flow for that matter) would be the preferred choices.

From a **product**/**development** point of view, the key things to put in place would be:
- Follow an agile development approach. Using a combination of **Kanban** and **Scrum** methodologies would allow for everyone to be on the same page when it comes to the general state of completion of the project while still be able to focus on their tasks.  
  Since the deadline is short, shorter sprints than the usual 2 weeks would be established, perhaps **9** to **11** days.
- **Jira** would be the preferred Kanban visualization and issue-tracking tool.
- Before the beginning of each sprint, a meeting would be held in which all the team members would talk about the issues in order to get a better grasp of them from a technical standpoint as well as to gain insight on what the other teams are working on, coordinate dependencies between teams etc.  
  During these meetings, the complexity of each issue would be estimated using a fibonacci sequence-based points system, in which each member of the team would assign each task a value, and a consensus would be reached as per the time each issue should take. This measures would then be used to calculate the amount of issues can be resolved in each sprint.
- Daily **stand-up meetings** would be held each morning, in which each person would briefly talk about what they did the day before, the struggles they might find along the way, etc. and also what they plan on doing on that day.  
  This creates more cohesion between the team, helps release some of the frustration when someone gets stuck on a problem and also gives the feeling they're not alone against unknown issues and struggles.
- At the end of each sprint, each person would prepare a short **demo** on the functionality they've successfully delivered, perhaps uniting multiple teams if they've been working on a common feature.  
  This is another one of those practices that might seen wasteful, but it helps keep people motivated and focused, since they can see with their own eyes things are getting done and the project is moving forward.
- An instant messaging tool such as **Slack** or **Discord** would be used by the team to communicate, make calls, share code snippets as well as gifs and memes, which is also a very important component in order to create camaraderie and bond between people.  
  A good addition to this would be to develop a **bot** program that integrates on the chat tool and that has access to the cloud deployments in order to automate some tasks such as re-dimensioning containers, trigger alarms, report performance issues, deploy builds, etc.
- Each member of the team should handle the entire lifecycle of the issues they develop and must not consider it done until every aspect of it is completed: coding, testing, deployment and assuring everything is fine in the production environment.  
  Additionally, a set of automated tests would be defined in collaboration with the QA team.
  
When it comes to the team and company culture, a **work hard play hard** mentality should be installed since the beginning.  
Building a tech team from the ground up is no easy task, and therefore everyone should feel like an integral part of the company and that they can learn from everybody else and grow along with the company and the product.  
Most people will work with some technologies for the first time, and hence it should be acceptable to ask for help whenever someone gets stuck or feels like the task is too complicated/they don't have enough context, not without having tried hard enough to tackle the issue on their own first.

A very healthy practice is to prepare a short lecture for the rest of the team on some technology, tool, technique etc. they knew already that's being applied to the project or something they've had to research in order to apply it. Knowledge spreading is good for everyone and will allow for other members of the team to be able to help each other in the future.

Hard work must also be rewarded and acknowledged by the company, therefore team-building activities and all-hands meetings should be held regularly, even if it's just a simple thing like having lunch together or going for a drink after work.  